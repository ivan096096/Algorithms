package Lessons.lesson_1;

public class HomeWork {
/* 2. Определить сложность следующих алгоритмов:
      -. Поиск элемента массива с известным индексом                        => O(1)
      -. Дублирование одномерного массива через foreach                     => O(n)
      -. Удаление элемента массива с известным индексом без сдвига          => O(n)
      -. Удаление элемента массива с неизвестным индексом без сдвига        => O(log n)
       -. Удаление элемента массива с неизвестным индексом со сдвига        => O(n)
*/
//======================================================================================
  /*  3. Определить сложность следующих алгоритмов. Сколько произойдет итераций?

  a)
  int n = 10000;
  List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i++) {                     => O( log n)
    for (int j = 1; j < n; j *= 2) {
      arrayList.add(i * j);
    }
  }

  b)
-----------------------------------------------------------------------------------
  int n = 10000;
  List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i += 2) {            => O(n)
    for (int j = i; j < n; j++) {
      arrayList.add(i * j);
    }
  }
  с)

  int n = 10000;
  List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i ++) {              => O(n)
    for (int j = 0; j < n; j++) {
      arrayList.add(i * j);
      n--;
    }
  }

-------------------------------------------------------------------------------------
  d*)
      ```

  factorial(12)

  public static int factorial(int n) {
    if (n == 1) {
      return n;                                    => O(n)
    }
    return n * factorial(n - 1);
  }
------------------------------------------------------------------------------------
  e*)
  fib(20);

  public static int fib(int n) {
    if (n == 1) || (n == 2)) {
      return n;                                    => O(2^n)
    }
    return fib(n - 1) + fib(n - 2);
  }


   */
}
